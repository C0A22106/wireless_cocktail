// Interaction.cpp : 実装ファイル
// Interaction.cpp : ??????
// グラフィックス描画部分を抽出した開発用コー

#include "pch.h"
#include "framework.h"
#include "WirelessMotion.h"
#include "WirelessMotionDlg.h"
#include "afxdialogex.h"
#include "cstdlib"
#include "random"
#include "string"
#include "vector"

// MFC管理下にないグローバル変数への参照
extern int rf_status; // ワイヤレス通信の実行状況を表す変数　0 ... 実行なし	1 ... 実行あり
extern int rf_firsttime; // パケットエラーの計数開始時のみ1になるフラフ
extern int rf_errcnt; // ワイヤレス通信におけるパケットエラーの累計数
extern int rf_interlock; // 描画時間が長い際にワイヤレス通信スレッドを優先実行するためのフラグ

#define GRAPH_Y_RANGE 4000.0					// グラフY軸の数値幅
#define GRAPH_Y_OFFSET (GRAPH_Y_RANGE*0.5)		// データの値がゼロの時のY軸値（オフセット値）
#define PHI_RANGE 360.0
#define THETA_RANGE 180.0
#define PHI_OFFSET (PHI_RANGE*0.5)
#define THETA_OFFSET (THETA_RANGE*0.5)

// モーションデータの内容
extern double databuf[DATASORT][MAXDATASIZE];		// グローバル変数配列にセンサデータを格納する
// 0 ... seq
// 1, 2, 3 ... ax, ay, az ３軸加速度(G)
// 4, 5, 6 ... wx, wy, wz ３軸角速度(dps)
// 7, 8, 9 ... e4x, e4y, e4z 重力姿勢角ベクトル（direction cosine形式)
// 10 ... alpha (信頼度係数, 0から1までの浮動小数点数値）
// 11, 12 ... 前腕傾斜角θ, 前腕ひねり角φ（deg)
// 13, 14, 15 ... jx, jy, jz ３軸加加速度（jerk) (任意単位）
// 16, 17, 18 ... ajx, ajy, ajz ３軸角加加速度（angular jerk) (任意単位)
extern int datasize;

//オリジナル変数初期化
int dir = 0;
int period = 0;
double val;
int peak_timing = -1;
double peak_val = 0.0;
int stop_count = 0;
double sum_swing_speed = 0;
double sum_theta_dif = 0;
int sample_count = 0;
double AATL = 0;
double BPM = 0;
clock_t start_time, end_time;
BOOLEAN pour, stop = FALSE;

// ランダムピック
std::string RandomPick(int shakeCount)
{
	// テーブル定義
	std::vector<std::vector<std::string>> tables = {
		{"カクテル", "ワイン", "ビール", "ウイスキー", "焼酎", "日本酒", "リキュール", "ノンアルコール"}, // テーブル1
		{"イタリアン", "フレンチ", "和食", "中華", "韓国料理", "タイ料理", "インド料理", "アメリカン"},   // テーブル2
		{"ステーキ", "寿司", "ラーメン", "カレー", "パスタ", "ピザ", "ハンバーガー", "お好み焼き"}       // テーブル3
	};

	// テーブル選択ロジック
	std::vector<std::string> selectedTable;
	if (shakeCount <= 3) {
		selectedTable = tables[0];
	}
	else if (shakeCount <= 6) {
		selectedTable = tables[1];
	}
	else {
		selectedTable = tables[2];
	}

	// ランダムでアイテムを選択
	std::random_device rd;
	std::mt19937 gen(rd());
	std::uniform_int_distribution<> dis(0, selectedTable.size() - 1);
	std::string randomItem = selectedTable[dis(gen)];

	return randomItem;
}

std::string randomresult = RandomPick(3);



extern double bpm_buf[2][MAXDATASIZE];

//????????????????
void jud_pour(int time) {
	if ((stop_count >= 20) && (databuf[12][time] >= 120.0) && (databuf[12][time] <= 180.0)) {
		pour = TRUE;
	}
}

//????????stop_count?1????
void jud_stop(int time) {
	if (databuf[16][time] <= 2000) {
		stop_count++;
	}
	else {
		stop_count = 0;
	}
}

// ???

// ?????????????
enum Mode
{
	idol, // ?????????
	shake, // ???????????
	finish, // ?????????????
	result // ????
};

Mode mode = idol;

// ?????????????
void start_shake(int time)
{
	if (databuf[16][time] >= 2000)
	{
		shaking = TRUE;
	}
}

// ?????

//????????????????
void jud_pour(int time) {
	if ((stop_count >= 20) && (databuf[12][time] >= 120.0) && (databuf[12][time] <= 180.0)) {
		pour = TRUE;
	}
}

//????????stop_count?1????
void jud_stop(int time) {
	if (databuf[16][time] <= 2000) {
		stop_count++;
	}
	else {
		stop_count = 0;
	}
}

// ????????????????????????

LRESULT CWirelessMotionDlg::OnMessageRCV(WPARAM wParam, LPARAM lParam)
// ??????????????????????
// MFC??????????GDI??????????????
// WPARAM?LPARAM?????????????????????????????????
{
	// ?????
	// ??????????????????????ID?IDC_PICT1???????????
	// ?????????????????mPICT1???????????m:??????????
	// ?????????????????????????????????

	// ?????GDI???????????????????????????????

	// ????GDI????????????????????????
	CClientDC myPictDC(&mPICT1); // Picture Control????????mPICT1???????????????????
	CRect myRect; // ??????????????????
	CDC myDC; // ?????????????????????
	int xsize, ysize;
	CString s; // ?????????????????????

	int start;	// ???????????????????????
	int plot_count;	// ?????????????
	double xgain, ygain; // ????????????????
	if (rf_status == 1) {
		start = datasize - graphspan;
		if (start < 0) {
			start = 0;
		}
	}
	else {
		start = datapoint; // ??????????
	}

	plot_count = graphspan; // ??????????????????????????????????

	if((start + plot_count) > datasize){
		plot_count = datasize - start;	// ?????????????plot_count?????????
	}

	if (plot_count < 2) return TRUE; // ????????????????????


	mPICT1.GetClientRect(myRect); //Picture Control??????????????????????????????
	xsize = myRect.Width();
	xgain = (double)xsize / (double)plot_count; // 1????????X????????????
	ysize = myRect.Height();
	ygain = (double)ysize / GRAPH_Y_RANGE; // Y???????????????????????????

	myDC.CreateCompatibleDC(&myPictDC);	//mPICT1????????????????????????????????
	HBITMAP memBM = CreateCompatibleBitmap(myPictDC, xsize, ysize); // ??????????????????????
	memBM = CreateCompatibleBitmap(myPictDC, xsize, ysize);
	SelectObject(myDC, memBM); // ?????????????????????????????????

	myDC.FillSolidRect(myRect, RGB(255, 255, 255)); // ????????????
	CPen myPen(PS_SOLID, 1, RGB(0, 0, 0)); // ??????SOLID?????????1????)???R, G, B)
	CPen* oldPen = myDC.SelectObject(&myPen);	// ???myPen?????????????????oldPen??????

	// ????????????
	// ???????????start
	// ????????total
	// X????????????xgain (double)
	// Y????????????ygain (double)
	// Y??????????????OFFSET (double)

	int i, xx, yy;

	for (i = 0; i < plot_count; i++) {
		xx = (int)(xgain * (double)i);
		yy = (int)(ygain * (-databuf[6][start + i] + GRAPH_Y_OFFSET));
		// ???????????????????????
		xx = (xx < 0) ? 0 : xx;
		yy = (yy < 0) ? 0 : yy;
		xx = (xx > (xsize - 1)) ? xsize - 1 : xx;
		yy = (yy > (ysize - 1)) ? ysize - 1 : yy;
		if (i == 0) {
			myDC.MoveTo(xx, yy);	// ?????( xx, yy)??????????????????????????
		}
		else {
			myDC.LineTo(xx, yy);	// ????? ( xx, yy)????????????
		}
	}

	// ???
	// ????
	// ????????????????????
	switch (mode)
	{
		// ??????
		case idol:
			break;

		// ?????????
		case shake:
			break;

		// ????
		case finish:
			break;

		// ?????
		case result:
			break;
	}

	// ?????

	// ???????????

	myPictDC.BitBlt(0, 0, xsize, ysize, &myDC, 0, 0, SRCCOPY); // ????????????myPictDC)?????????

	myDC.SelectObject(oldPen);	// ???????????

	// ???????????
	// Jun. 26, 2024

	CClientDC myPictDC2(&mPICT2); // Picture Control????????mPICT2???????????????????
	CRect myRect2; // ??????????????????
	CDC myDC2; // ?????????????????????
	int xsize2, ysize2;

	int start2;	// ???????????????????????
	int plot_count2;	// ?????????????
	double xgain2, ygain2; // ????????????????

	if (rf_status == 1) {
		start2 = datasize - graphspan;
		if (start2 < 0) {
			start2 = 0;
		}
	}
	else {
		start2 = datapoint; // ??????????
	}

	plot_count2 = graphspan; // ??????????????????????????????????

	if ((start2 + plot_count2) > datasize) {
		plot_count2 = datasize - start2;	// ?????????????plot_count?????????
	}

	if (plot_count2 < 2) return TRUE; // ????????????????????

	mPICT2.GetClientRect(myRect2); //Picture Control??????????????????????????????
	xsize2 = myRect2.Width();
	xgain2 = (double)xsize2 / PHI_RANGE;	// X????????????????????????????
	ysize2 = myRect2.Height();
	ygain2 = (double)ysize2 / THETA_RANGE; // Y???????????????????????????

	myDC2.CreateCompatibleDC(&myPictDC2);	//mPICT1????????????????????????????????
	HBITMAP memBM2 = CreateCompatibleBitmap(myPictDC2, xsize2, ysize2); // ??????????????????????
	memBM2 = CreateCompatibleBitmap(myPictDC2, xsize2, ysize2);
	SelectObject(myDC2, memBM2); // ?????????????????????????????????

	myDC2.FillSolidRect(myRect2, RGB(255, 255, 255)); // ????????????
	CPen myPen2(PS_SOLID, 1, RGB(0, 0, 0)); // ??????SOLID?????????1????)???R, G, B)
	CPen* oldPen2 = myDC2.SelectObject(&myPen2);	// ???myPen?????????????????oldPen??????

	// ????????????
	// ???????????start
	// ????????total
	// X????????????xgain (double)
	// Y????????????ygain (double)
	// X?????????????  PHI_OFFSET (double)
	// Y??????????????THETA_OFFSET (double)

//	int i, xx, yy;

	for (i = 0; i < plot_count2; i++) {
		xx = (int)(xgain2 * (-databuf[12][start2 + i] + PHI_OFFSET));
		yy = (int)(ygain2 * (databuf[11][start2 + i] + THETA_OFFSET));
		// ???????????????????????
		xx = (xx < 0) ? 0 : xx;
		yy = (yy < 0) ? 0 : yy;
		xx = (xx > (xsize - 1)) ? xsize - 1 : xx;
		yy = (yy > (ysize - 1)) ? ysize - 1 : yy;
		if (i == 0) {
			myDC2.MoveTo(xx, yy);	// ?????( xx, yy)??????????????????????????
		}
		else {
			myDC2.LineTo(xx, yy);	// ????? ( xx, yy)????????????
		}
	}

	// ???????????

	myPictDC2.BitBlt(0, 0, xsize2, ysize2, &myDC2, 0, 0, SRCCOPY); // ????????????myPictDC)?????????

	myDC2.SelectObject(oldPen2);	// ???????????


	// ??????????????????

	if (rf_status == 1) {
		s.Format(_T("Sample Count = %d Error = %d"), start, rf_errcnt);
	}
	else {
		s.Format(_T("Sample Count = %d"), start);
	}
	msgED.SetWindowTextW(s);
	DeleteDC(myDC); // ???????????????????????
	DeleteObject(memBM); // ??????????????????????

	DeleteDC(myDC2);
	DeleteObject(memBM2);

	rf_interlock = 0; // ????????????????????????

	//???????
	CString mes_swing;
	CString mes_wrist;
	CString mes_result;
	CString mes_random;
	val = databuf[4][start];

	AATL += abs(databuf[16][start]);

	//1????????????????????sum_data_dif?????
	double wrist_def;
	wrist_def = databuf[12][start] - databuf[12][start - 1];
	if (wrist_def < 0) {
		sum_theta_dif += -1 * wrist_def;
	}
	else {
		sum_theta_dif += wrist_def;
	}

	sample_count++;

	//???????????
	jud_stop(start);

	//????????????????????????
	if (stop_count >= 20) {
		dir = 0;
		period = 0;
		peak_timing = -1;
		peak_val = 0.0;
		sum_swing_speed = 0;
		sum_theta_dif = 0;
		sample_count = 0;
	}

	//??????????????????????????
	jud_pour(start);


	//????????????????????????
	if (stop_count >= 20) {
		dir = 0;
		period = 0;
		peak_timing = -1;
		peak_val = 0.0;
		sum_swing_speed = 0;
		sum_theta_dif = 0;
		sample_count = 0;
	}

	//??????????????????????????
	jud_pour(start);

	// ???
	// ??????????????????
	start_shake(start);

	if (shaking == TRUE && mode == idol)
	{
		mode = shake; // ???????????????
	}

	if (pour == TRUE && mode == shake)
	{
		mode = finish; // ????????????????
	}

	// ?????

	//??????????????????
	//dir?0??????????1????????
	if (dir == 0) {
		if (val < 0.0) {
			dir = 1;
			peak_timing = start;
		}
		else {
			if (val > peak_val) {
				peak_val = val;
				peak_timing = start;
			}
		}
	}
	else {
		if (val >= 0.0) {
			dir = 0;
			peak_val = val;
			sum_swing_speed += start - peak_timing;
			end_time = clock();
			BPM = 60.0 / ((double)(end_time - start_time) / CLOCKS_PER_SEC);
			peak_timing = start;
			start_time = clock();
			AATL = 0.0;
			period++;
		}
		else {
			if (val < peak_val) {
				peak_val = val;
				peak_timing = start;
			}
		}
	}

	bpm_buf[1][start] = BPM;

	double swing_average = (double)(sum_swing_speed / period);
	double theta_average = (double)(sum_theta_dif / sample_count);
	double swing_score = (1 - (swing_average - 1) * 0.5) * 100;
	double theta_score = (theta_average - 10) * 10;
	double whole_score = swing_score + theta_score;

	// ???
	// ??????????????????
	switch (mode)
	{
	case idol:
		s.Format(_T("Screem Mode idol"));
		break;

	case shake:
		s.Format(_T("Screem Mode shake"));
		break;

	case finish:
		s.Format(_T("Screem Mode finish"));
		break;

	case result:
		s.Format(_T("Screem Mode result"));
		break;
	}

	msgED.SetWindowTextW(s);

	// ?????

	mes_swing.Format(_T("????: %lf s\r\n???: %lf"), swing_average * 32.0, swing_score);
	mes_wrist.Format(_T("????: %lf ?\r\n???: %lf"), theta_average, theta_score);
	mes_result.Format(_T("?????: %lf\r\nBPM: %lf\r\npour: %d"), whole_score, bpm_buf[0][start], pour);
	msgED2.SetWindowTextW(mes_wrist);

	msgED3.SetWindowTextW(mes_swing);
	msgED4.SetWindowTextW(mes_result);

	//?????????

	return TRUE; // LRESULT??????????????????????
}