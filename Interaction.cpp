// Interaction.cpp : ??????
// Interaction.cpp : ??????
// ??????????????????????

#include "pch.h"
#include "framework.h"
#include "WirelessMotion.h"
#include "WirelessMotionDlg.h"
#include "afxdialogex.h"
#include "cstdlib"
#include "random"
#include "string"
#include "vector"

// MFC?????????????????
extern int rf_status; // ??????????????????0 ... ????	1 ... ????
extern int rf_firsttime; // ???????????????1??????
extern int rf_errcnt; // ??????????????????????
extern int rf_interlock; // ?????????????????????????????????

#define GRAPH_Y_RANGE 4000.0					// ???Y?????
#define GRAPH_Y_OFFSET (GRAPH_Y_RANGE*0.5)		// ???????????Y??????????
#define PHI_RANGE 360.0
#define THETA_RANGE 180.0
#define PHI_OFFSET (PHI_RANGE*0.5)
#define THETA_OFFSET (THETA_RANGE*0.5)

// ???????????
extern double databuf[DATASORT][MAXDATASIZE];		// ?????????????????????
// 0 ... seq
// 1, 2, 3 ... ax, ay, az ?????(G)
// 4, 5, 6 ... wx, wy, wz ?????(dps)
// 7, 8, 9 ... e4x, e4y, e4z ??????????direction cosine??)
// 10 ... alpha (?????, 0??1???????????
// 11, 12 ... ??????, ????????deg)
// 13, 14, 15 ... jx, jy, jz ???????jerk) (?????
// 16, 17, 18 ... ajx, ajy, ajz ????????angular jerk) (????)
extern int datasize;

//??????????
int dir = 0;
int period = 0;
double val;
int peak_timing = -1;
double peak_val = 0.0;
int stop_count = 0;
double sum_swing_speed = 0;
double sum_theta_dif = 0;
int sample_count = 0;
double AATL = 0;
double BPM = 0;
clock_t start_time, end_time;
BOOLEAN pour, stop = FALSE;

// ???????
std::string RandomPick(int shakeCount)
{
	// ??????
	std::vector<std::vector<std::string>> tables = {
		{"????", "???", "???", "?????", "??", "???", "?????", "???????"}, // ????1
		{"?????", "????", "??", "??", "????", "????", "?????", "?????"},   // ????2
		{"????", "??", "????", "???", "???", "??", "??????", "?????"}       // ????3
	};

	// ??????????
	std::vector<std::string> selectedTable;
	if (shakeCount <= 3) {
		selectedTable = tables[0];
	}
	else if (shakeCount <= 6) {
		selectedTable = tables[1];
	}
	else {
		selectedTable = tables[2];
	}

	// ????????????
	std::random_device rd;
	std::mt19937 gen(rd());
	std::uniform_int_distribution<> dis(0, selectedTable.size() - 1);
	std::string randomItem = selectedTable[dis(gen)];

	return randomItem;
}

std::string randomresult = RandomPick(3);



extern double bpm_buf[2][MAXDATASIZE];

//????????????????
void jud_pour(int time) {
	if ((stop_count >= 20) && (databuf[12][time] >= 120.0) && (databuf[12][time] <= 180.0)) {
		pour = TRUE;
	}
}

//????????stop_count?1????
void jud_stop(int time) {
	if (databuf[16][time] <= 2000) {
		stop_count++;
	}
	else {
		stop_count = 0;
	}
}

// ???

// ?????????????
enum Mode
{
	idol, // ?????????
	shake, // ???????????
	finish, // ?????????????
	result // ????
};

Mode mode = idol;

// ?????????????
void start_shake(int time)
{
	if (databuf[16][time] >= 2000)
	{
		shaking = TRUE;
	}
}

// ?????

//????????????????
void jud_pour(int time) {
	if ((stop_count >= 20) && (databuf[12][time] >= 120.0) && (databuf[12][time] <= 180.0)) {
		pour = TRUE;
	}
}

//????????stop_count?1????
void jud_stop(int time) {
	if (databuf[16][time] <= 2000) {
		stop_count++;
	}
	else {
		stop_count = 0;
	}
}

// ????????????????????????

LRESULT CWirelessMotionDlg::OnMessageRCV(WPARAM wParam, LPARAM lParam)
// ??????????????????????
// MFC??????????GDI??????????????
// WPARAM?LPARAM?????????????????????????????????
{
	// ?????
	// ??????????????????????ID?IDC_PICT1???????????
	// ?????????????????mPICT1???????????m:??????????
	// ?????????????????????????????????

	// ?????GDI???????????????????????????????

	// ????GDI????????????????????????
	CClientDC myPictDC(&mPICT1); // Picture Control????????mPICT1???????????????????
	CRect myRect; // ??????????????????
	CDC myDC; // ?????????????????????
	int xsize, ysize;
	CString s; // ?????????????????????

	int start;	// ???????????????????????
	int plot_count;	// ?????????????
	double xgain, ygain; // ????????????????
	if (rf_status == 1) {
		start = datasize - graphspan;
		if (start < 0) {
			start = 0;
		}
	}
	else {
		start = datapoint; // ??????????
	}

	plot_count = graphspan; // ??????????????????????????????????

	if((start + plot_count) > datasize){
		plot_count = datasize - start;	// ?????????????plot_count?????????
	}

	if (plot_count < 2) return TRUE; // ????????????????????


	mPICT1.GetClientRect(myRect); //Picture Control??????????????????????????????
	xsize = myRect.Width();
	xgain = (double)xsize / (double)plot_count; // 1????????X????????????
	ysize = myRect.Height();
	ygain = (double)ysize / GRAPH_Y_RANGE; // Y???????????????????????????

	myDC.CreateCompatibleDC(&myPictDC);	//mPICT1????????????????????????????????
	HBITMAP memBM = CreateCompatibleBitmap(myPictDC, xsize, ysize); // ??????????????????????
	memBM = CreateCompatibleBitmap(myPictDC, xsize, ysize);
	SelectObject(myDC, memBM); // ?????????????????????????????????

	myDC.FillSolidRect(myRect, RGB(255, 255, 255)); // ????????????
	CPen myPen(PS_SOLID, 1, RGB(0, 0, 0)); // ??????SOLID?????????1????)???R, G, B)
	CPen* oldPen = myDC.SelectObject(&myPen);	// ???myPen?????????????????oldPen??????

	// ????????????
	// ???????????start
	// ????????total
	// X????????????xgain (double)
	// Y????????????ygain (double)
	// Y??????????????OFFSET (double)

	int i, xx, yy;

	for (i = 0; i < plot_count; i++) {
		xx = (int)(xgain * (double)i);
		yy = (int)(ygain * (-databuf[6][start + i] + GRAPH_Y_OFFSET));
		// ???????????????????????
		xx = (xx < 0) ? 0 : xx;
		yy = (yy < 0) ? 0 : yy;
		xx = (xx > (xsize - 1)) ? xsize - 1 : xx;
		yy = (yy > (ysize - 1)) ? ysize - 1 : yy;
		if (i == 0) {
			myDC.MoveTo(xx, yy);	// ?????( xx, yy)??????????????????????????
		}
		else {
			myDC.LineTo(xx, yy);	// ????? ( xx, yy)????????????
		}
	}

	// ???
	// ????
	// ????????????????????
	switch (mode)
	{
		// ??????
		case idol:
			break;

		// ?????????
		case shake:
			break;

		// ????
		case finish:
			break;

		// ?????
		case result:
			break;
	}

	// ?????

	// ???????????

	myPictDC.BitBlt(0, 0, xsize, ysize, &myDC, 0, 0, SRCCOPY); // ????????????myPictDC)?????????

	myDC.SelectObject(oldPen);	// ???????????

	// ???????????
	// Jun. 26, 2024

	CClientDC myPictDC2(&mPICT2); // Picture Control????????mPICT2???????????????????
	CRect myRect2; // ??????????????????
	CDC myDC2; // ?????????????????????
	int xsize2, ysize2;

	int start2;	// ???????????????????????
	int plot_count2;	// ?????????????
	double xgain2, ygain2; // ????????????????

	if (rf_status == 1) {
		start2 = datasize - graphspan;
		if (start2 < 0) {
			start2 = 0;
		}
	}
	else {
		start2 = datapoint; // ??????????
	}

	plot_count2 = graphspan; // ??????????????????????????????????

	if ((start2 + plot_count2) > datasize) {
		plot_count2 = datasize - start2;	// ?????????????plot_count?????????
	}

	if (plot_count2 < 2) return TRUE; // ????????????????????

	mPICT2.GetClientRect(myRect2); //Picture Control??????????????????????????????
	xsize2 = myRect2.Width();
	xgain2 = (double)xsize2 / PHI_RANGE;	// X????????????????????????????
	ysize2 = myRect2.Height();
	ygain2 = (double)ysize2 / THETA_RANGE; // Y???????????????????????????

	myDC2.CreateCompatibleDC(&myPictDC2);	//mPICT1????????????????????????????????
	HBITMAP memBM2 = CreateCompatibleBitmap(myPictDC2, xsize2, ysize2); // ??????????????????????
	memBM2 = CreateCompatibleBitmap(myPictDC2, xsize2, ysize2);
	SelectObject(myDC2, memBM2); // ?????????????????????????????????

	myDC2.FillSolidRect(myRect2, RGB(255, 255, 255)); // ????????????
	CPen myPen2(PS_SOLID, 1, RGB(0, 0, 0)); // ??????SOLID?????????1????)???R, G, B)
	CPen* oldPen2 = myDC2.SelectObject(&myPen2);	// ???myPen?????????????????oldPen??????

	// ????????????
	// ???????????start
	// ????????total
	// X????????????xgain (double)
	// Y????????????ygain (double)
	// X?????????????  PHI_OFFSET (double)
	// Y??????????????THETA_OFFSET (double)

//	int i, xx, yy;

	for (i = 0; i < plot_count2; i++) {
		xx = (int)(xgain2 * (-databuf[12][start2 + i] + PHI_OFFSET));
		yy = (int)(ygain2 * (databuf[11][start2 + i] + THETA_OFFSET));
		// ???????????????????????
		xx = (xx < 0) ? 0 : xx;
		yy = (yy < 0) ? 0 : yy;
		xx = (xx > (xsize - 1)) ? xsize - 1 : xx;
		yy = (yy > (ysize - 1)) ? ysize - 1 : yy;
		if (i == 0) {
			myDC2.MoveTo(xx, yy);	// ?????( xx, yy)??????????????????????????
		}
		else {
			myDC2.LineTo(xx, yy);	// ????? ( xx, yy)????????????
		}
	}

	// ???????????

	myPictDC2.BitBlt(0, 0, xsize2, ysize2, &myDC2, 0, 0, SRCCOPY); // ????????????myPictDC)?????????

	myDC2.SelectObject(oldPen2);	// ???????????


	// ??????????????????

	if (rf_status == 1) {
		s.Format(_T("Sample Count = %d Error = %d"), start, rf_errcnt);
	}
	else {
		s.Format(_T("Sample Count = %d"), start);
	}
	msgED.SetWindowTextW(s);
	DeleteDC(myDC); // ???????????????????????
	DeleteObject(memBM); // ??????????????????????

	DeleteDC(myDC2);
	DeleteObject(memBM2);

	rf_interlock = 0; // ????????????????????????
	// Ç†

	rf_interlock = 0; // ï`âÊÇ™äÆóπÇµÇΩÇ±Ç∆ÇÉOÉçÅ[ÉoÉãïœêîÇâÓÇµÇƒì`Ç¶ÇÈ

	//???????
	CString mes_swing;
	CString mes_wrist;
	CString mes_result;
	CString mes_random;
	val = databuf[4][start];

	AATL += abs(databuf[16][start]);

	//1????????????????????sum_data_dif?????
	double wrist_def;
	wrist_def = databuf[12][start] - databuf[12][start - 1];
	if (wrist_def < 0) {
		sum_theta_dif += -1 * wrist_def;
	}
	else {
		sum_theta_dif += wrist_def;
	}

	sample_count++;

	//???????????
	jud_stop(start);

	//????????????????????????
	if (stop_count >= 20) {
		dir = 0;
		period = 0;
		peak_timing = -1;
		peak_val = 0.0;
		sum_swing_speed = 0;
		sum_theta_dif = 0;
		sample_count = 0;
	}

	//??????????????????????????
	jud_pour(start);


	//????????????????????????
	if (stop_count >= 20) {
		dir = 0;
		period = 0;
		peak_timing = -1;
		peak_val = 0.0;
		sum_swing_speed = 0;
		sum_theta_dif = 0;
		sample_count = 0;
	}

	//??????????????????????????
	jud_pour(start);

	// ???
	// ??????????????????
	start_shake(start);

	if (shaking == TRUE && mode == idol)
	{
		mode = shake; // ???????????????
	}

	if (pour == TRUE && mode == shake)
	{
		mode = finish; // ????????????????
	}

	// ?????

	//??????????????????
	//dir?0??????????1????????
	if (dir == 0) {
		if (val < 0.0) {
			dir = 1;
			peak_timing = start;
		}
		else {
			if (val > peak_val) {
				peak_val = val;
				peak_timing = start;
			}
		}
	}
	else {
		if (val >= 0.0) {
			dir = 0;
			peak_val = val;
			sum_swing_speed += start - peak_timing;
			end_time = clock();
			BPM = 60.0 / ((double)(end_time - start_time) / CLOCKS_PER_SEC);
			peak_timing = start;
			start_time = clock();
			AATL = 0.0;
			period++;
		}
		else {
			if (val < peak_val) {
				peak_val = val;
				peak_timing = start;
			}
		}
	}

	bpm_buf[1][start] = BPM;

	double swing_average = (double)(sum_swing_speed / period);
	double theta_average = (double)(sum_theta_dif / sample_count);
	double swing_score = (1 - (swing_average - 1) * 0.5) * 100;
	double theta_score = (theta_average - 10) * 10;
	double whole_score = swing_score + theta_score;

	// ???
	// ??????????????????
	switch (mode)
	{
	case idol:
		s.Format(_T("Screem Mode idol"));
		break;

	case shake:
		s.Format(_T("Screem Mode shake"));
		break;

	case finish:
		s.Format(_T("Screem Mode finish"));
		break;

	case result:
		s.Format(_T("Screem Mode result"));
		break;
	}

	msgED.SetWindowTextW(s);

	// ?????

	mes_swing.Format(_T("????: %lf s\r\n???: %lf"), swing_average * 32.0, swing_score);
	mes_wrist.Format(_T("????: %lf ?\r\n???: %lf"), theta_average, theta_score);
	mes_result.Format(_T("?????: %lf\r\nBPM: %lf\r\npour: %d"), whole_score, bpm_buf[0][start], pour);
	msgED2.SetWindowTextW(mes_wrist);

	msgED3.SetWindowTextW(mes_swing);
	msgED4.SetWindowTextW(mes_result);

	//?????????

	return TRUE; // LRESULT??????????????????????
}